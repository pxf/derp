\chapter{Implementation}

\pic[0.35]{img/lightning_screens.png}{\emph{\textbf{Top left:}} The job initiator showing (rendered using OpenGL locally) a simple teapot model before being it ray traced. \emph{\textbf{Top right:}} The view right after a job has been sent to the clients (no results has been received yet). Each task can be seen here with corresponding task id for easier debugging. \emph{\textbf{Bottom left:}} About half (33 of 64) of the tasks has been completed and received, as shown by the progress bar. Visual task id numbering has been disabled here. \emph{\textbf{Bottom right:}} Finished image, all tasks completed and received. Showing a simple reflection of a tea pot in a sphere.}

\section{Worker Client}
The client has two bound sockets for incoming connections. The first is used by the tracker after the client have initated contact to fully establish the connection and make sure the client is connectable.
The second is used by the job initator and other clients when they have jobs that needs to be handled.
When a client have received jobs, it fills it's internal queue and tries to send the rest to idle workers. 
If it is not connected to any idle workers, it asks the tracker for more.

To make sure the network is responsive enough, every node sends PING-messages at a given interval, and closes the connections that does not respond in time.


\section{Ray-Tracer Job Processor}
Even if the worker client would be able to handle many different job processors, the main focus were from the start to create a naïve ray-tracer processor, mainly because the ease to divide jobs into smaller tasks. Implementation started with some very simple tests consisting of ray-sphere intersections, and were further developed to handle ray-triangle intersections. The lightning calculations are also very simple, but fit the purpose of a simple prototype.

Each job is essentially a serialized 3D scene, and consists of a collection of triangles, a kd-tree (explained in more detail below), materials, light sources and the cameras position and orientation. The job initiator serialize and package this data, and it is then up to our job processor to unpack the data and use it for each task.

Each of the tasks that make up a job, is simply a predefined region of the final image. The job processor runs a shading function for each pixel it has to render, essentially ray traces a ray from the camera origin through each pixel into the scene. The shading function uses the data sent with the job (triangles, kd-tree, material and light information) to shade the pixels in the task region. As soon as a task is finished, the results are packed and pushed onto the result queue, where the client then takes care of sending it back to the job initiator.
%- Naïve raytracer implementation\\

- kd-tree like bass\\
  -- behövde snabbas upp, därför behövde vi ett kd-träd\\
  -- behövde indexera trianglarna istället för att lagra pekare -> pga serialiseringen\\
  
  
% - planned photon mapper job processor\\ <- tas upp i future work istället

\section{Tracker}
When a node connects to the tracker a new connection is established to the node's incoming socket from the tracker, and if it succeeds the first socket is closed in favor of the now outgoing connection.
This gives the network an automated way of testing whether the node is connectable or not.
After the connection has been fully established the node is given a unique ID that it uses whenever it talks to the tracker and other nodes.
Following types of messages are used for further communication.

\begin{description}
\item[Node requests more nodes] \hfill \\\\
If there are nodes available already they are returned, but if no such nodes exist the requesting node is instead put in a waiting queue.
\item[Node telling it is available to other nodes] \hfill \\\\
The node is tagged as being available for work, and if there are nodes in the waiting queue already they are to recieve this node until it's spent.
\end{description}

To be able to make smart decisions about the creation of the network, the tracker keeps a database on how the nodes are connected.

\section{Job Initiator}
Screenshots galore!
