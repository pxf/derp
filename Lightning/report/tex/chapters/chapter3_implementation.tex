\chapter{Implementation}

\pic[0.32]{img/lightning_screens.png}{\emph{\textbf{Top left:}} The job initiator showing (rendered using OpenGL locally) a simple teapot model before ray tracing. \emph{\textbf{Top right:}} The view right after a job has been sent to the clients (no results has been received yet). Each task can be seen here with corresponding task id for easier debugging. \emph{\textbf{Bottom left:}} About half (33 of 64) of the tasks are complete and received, as shown by the progress bar. Visual task id numbering has been disabled here. \emph{\textbf{Bottom right:}} Finished image, all tasks complete and received. Showing a simple reflection of a teapot in a sphere.}

\section{Worker Client}
The client has two bound sockets for incoming connections. The first socket is used by the tracker after the client has initated contact to fully establish the connection and make sure the client is connectable.
The second socket is used by the job initator and other clients when they have jobs that need to be handled.
When a client receives jobs, it fills its internal queue and tries to send the rest to idle workers.
If it is not connected to any idle workers, it asks the tracker for more.
After a job is done, it opens a connection to the job initiator and sends the completed data over the connection.

The client has three queues, handling all the incoming, outgoing and completed jobs.
\begin{description}
	\item[Internal queue] \hfill \\
	Holds all the jobs that the internal workers are going to process. The size of this queue can be changed in a way that makes the network efficient. However, the current implementation sets this to a fixed size.
	\item[External queue] \hfill \\
	All the jobs that the client have been given, which currently does not fit in the internal queue.
	When jobs exist in this queue, the client tries to send them to other clients, by either using already connected clients or asking the tracker for more.
	\item[Outgoing queue] \hfill \\
	When a job is completed it is put in this queue and a special \textit{Sender}-thread sends them to the job initiator one at a time.
\end{description}

Since the Lightning client should be able to process arbitrary complex computational data, speed is of the essence, and this is one of the reasons why C++ was chosen as the target implementation language for the client.

To make sure the network is responsive enough, every node sends PING-messages at a given interval, and closes the connections that does not respond in time.

\section{Ray-Tracer Job Processor}
Even if the worker client would be able to handle many different job processors, the main focus were from the start to create a naïve ray-tracer processor, mainly because the ease to divide jobs into smaller tasks. Implementation started with some very simple tests consisting of ray-sphere intersections, and were further developed to handle ray-triangle intersections. The lightning calculations are also very simple, but fit the purpose of a simple prototype.

Each job is essentially a serialized 3D scene, and consists of a collection of triangles, a kd-tree (explained in more detail below), materials, light sources and the cameras position and orientation. The job initiator serialize and package this data, and it is then up to our job processor to unpack the data and use it for each task.

Each of the tasks that make up a job, is simply a predefined region of the final image. The job processor runs a shading function for each pixel it has to render, essentially ray traces a ray from the camera origin through each pixel into the scene. The shading function uses the data sent with the job (triangles, kd-tree, material and light information) to shade the pixels in the task region. As soon as a task is finished, the results are packed and pushed onto the result queue, where the client then takes care of sending it back to the job initiator.
%- Naïve raytracer implementation\\

\subsection{KD-Tree}
In the very first ray tracer, a brute force algorithm was used for each ray against all the geometry in the scene. At first, this did not cause extreme performance costs as small scenes with simple objects was used. However, when using complex 3D objects with thousands of triangles was used, rendering the scene took several minutes and was thus impossible to work with. To address this issue, a spatial division scheme was implemented. There exists several different schemes with various benefits, but ultimately, a specialized KD tree algorithm was designed for the task, based on a paper by Ingo Wald [referens här]. 

As a tree can take several minutes to build, it is calculated offline once and then stored locally as a binary file. When loading a model, the renderer loads the cached file containing the binary kd-tree in almost no time.

The tree is constructed offline by a number of passes:

Pass 1: Construct a bounding volume for each primitive used in the scene. A bounding volume encapsulating all the primitives in the tree is also calculated. This is used for early hit detection by a ray-box intersection on the total volume.

Pass 2: Recursively build the tree. The following pseudo-algorithm describes the algorithm:

 1. if stopping criteria met then 
 2.   create leaf node and assign it with current work data
 4. calculate a bounding box for left and right child nodes
 3. for each axis do
 4.  for each split position do
 5.    calculate total SAH cost
 6.    if total cost is < current best cost then
 7.      set best axis and split position
 8. if the cost of not splitting is better than splitting then
 9.   create leaf node and assign it with current work data
10. create two inner nodes and assign with data
11. recurse on left and right nodes

Comments: 

1-2: The stopping criteria in this case is met when either the work set or the recursion depth is less than specific constants. Tweaking the value of these constants yield varying intersection performance as they determine the size of the tree (and thus also the speed of the algorithm). In this version, the criteria is work size < 8 and depth < 20, which works quite well.

5: SAH, or surface area heuristic calculates a cost value based on the volume of the left and right bounding boxes. A minimal cost creates a tight box around the primitives in the working data set and indicates the best split position of the split candidates (the min and max points of the primitives). The current split position splits the current node's bounding volume in two sides, left and right. The total cost is calucalted as follows: 

left SAH = volume of left bounding box

right SAH = volume of right bounding box

left primitives and right primitives indicates the amount of primitives in either bounding volume. 

\begin{equation}
total cost = left SAH * left primitives + right SAH * right primitives
\end{equation}

Pass 3: Build a cache-friendly tree that uses data indices instead of raw data from the tree in pass 2. As no pointers are used in the leaves, this tree can finally be serialized to a file, or sent over a network connection and used directly by clients with no re-calculation or processing.

When the tree is build, it can then be used in ray-primitive intersections when ray-tracing. This process is described as follows:

1. 

\section{Tracker}
When a node connects to the tracker a new connection is established to the node's incoming socket from the tracker, and if it succeeds the first socket is closed in favor of the now outgoing connection.
This gives the network an automated way of testing whether the node is connectable or not.
After the connection has been fully established the node is given a unique ID that it uses whenever it talks to the tracker and other nodes.
Following types of messages are used for further communication.

\begin{description}
\item[Node requests more nodes] \hfill \\\\
If there are nodes available already they are returned, but if no such nodes exist the requesting node is instead put in a waiting queue.
\item[Node telling it is available to other nodes] \hfill \\\\
The node is tagged as being available for work, and if there are nodes in the waiting queue already they are to recieve this node until it's spent.
\end{description}

To be able to make smart decisions about the creation of the network, the tracker keeps a database on how the nodes are connected.

\section{Job Initiator}
Screenshots galore!
