
\chapter{Renderer}

\section{Decoupled Rendering}
There are several reasons why decoupled rendering is justified in this project. As the editor will be developed using an OpenGL context, rendering the GUI will be directly dependent on frame rate. In effect, this means that rendering the output of a large pipeline might result in an unresponsive GUI.
Most importantly, this module enables users with low-end hardware to create and test pipelines with advanced functionality, not supported on their graphics processor. Users will be able to push changes to a central rendering back-end. This renderer may be running on a different computer with better hardware, to speed up the process and the interaction between multiple users.  Primarily, this functionality will focus on single-frame processing, but hopefully we will be able to support multiple-frame continuous rendering, such as animation loops. 

\section{Rendering Back-end}
The rendering backend itself is not especially interesting. It acts simply as a render server and provides no user interaction. Its function however, is essential. The rendering back-end executes the rendering of the pipeline layout constructed using the editor front-end. After performing each render pass in the pipeline, the renderer sends the result of each individual block back to the editor, making it possible for the user to inspect each step directly in the editor. 

This functionality is useful in many occasions. Consider creating a pipeline with several different components, such as High Dynamic Range rendering or deferred shading that require off-screen rendering to numerous render targets. Inspecting each individual pass in most game engines is not always intuitive and easily accessible, but nonetheless imperative when debugging shader output. In DERP, the result of each pass is either visible by hoovering the mouse over each component's individual output, or by clicking them. 