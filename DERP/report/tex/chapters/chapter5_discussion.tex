\chapter{Discussion}

\section{Engine}
We are quite satisfied with the game engine as a whole. So far we haven't encountered any major show stoppers, only minor issues which easily have been resolved. The module system works great as well, and the components we have implemented seem to be reasonably stable.

We were able to get the engine up and running quite quickly, many thanks to the following open source libraries: \texttt{enet}, \texttt{glew}, \texttt{glfw}, \texttt{jsoncpp}, \texttt{lua}, \texttt{openctm}, \texttt{rtaudio}, \texttt{soil}, \texttt{stb\_vorbis} and \texttt{zthread}.

\section{Network}
We initially decided to use ENet as a networking library for it's ease of use, speed and reability features. However, ENet uses UDP for communication, and it had some quirks to it when wanting to deliver packets both reliable and in-order. For this project in particular, using regular TCP sockets would have been a better choise and would have resulted in better networking \mbox{performance}.

\section{Renderer}

[inte så mycket att säga här kanske..? den gör ju det den ska liksom]

\section{Editor}
We are surprised how well the editor turned out, and how closely it came to our original proposed idea. Even though at the beginning it felt like a monumental task, in hindsight it feels that we made the right decision to implement our own GUI system, since it gave us the freedom and flexibility we needed. It made it possible for us to optimize the UI rendering for our own needs, while still being able to rework and redo fundamental architecture inside the script host application, without worrying about underlying script functionality as long as we expose the same features to the scripts with each iteration.

One of the problems we were afraid of from the start, were if implementing all the editors functionality via scripts could result in unresponsiveness or a "sluggish feeling" on slow computers. But this didn't surface as any practical problem in the finished application at all, we were in fact able to run the editor on very low end netbook without any problem.

The one thing we feel should have addressed early in development of the GUI system, is the possibility of arbitrary window sizes and resizing. This was something we felt the need for quite late in the development process, and was something we kept pushing aside for other more urgent fixes. But implementing such a feature would be something needed for future work, and should be possible to accomplish with minor tweaks to the GUI scripts. Another feature we originally planned were theme customization, but something we had to skip implementing to save time. In the very end of the development process we came up with a compromise, to let the user change the overall hue/colors of the theme. This could be done by implementing a graphics shader that at runtime modified the colors of the theme image. But also this feature was cut due to time constraints. 

%[snygg och fin, lätt att knåda med lua, widgetbasen kan enkelt användas till andra projekt]

%[synd att vi inte hann med hueshiftgrejen, den är lite väl brun nu kanske]

\section{Future Releases}
[saker som vi inte hann med eller så]

In large projects when the workspace gets cluttered from wires and boxes, a user can batch components together in groups. These groups can then be minimized or collapsed in order to achieve a better overview of the project. This functionality also serves as a performance increase, as each component and wire require processing power to visualize. 

Originally, it was intended to include user custom color schemes, manipulated by a hue-shift shader. Different color schemes enable users to customize the look of the whole editor to better suit the users preferences, such as light-dark contrast as well as general visual profile.

[shader inspector typ? så att man kan kolla i själva knåden vad som sker, alt. ändra, eller så ser man vart kompileringen sket sig, eftersom det sker på renderaren.]

[editor resizing]

[snyggare wires]

[någonting med att man kunde koppla om inuti själva komponenten, men jag minns inte vad det var bra för..]

\chapter{Conclusion}

[här kan man slänga in lite text från project notes också, som man kan referera till.. ]

[typ nått sånt här: "When rendering the output, the backend profiles each component and sends this data along with the finished frame back to the editor. The timing information is displayed somewhere on the component itself in the editor window. "]

[på det stora hela blev ju projektet nästan exakt som vi tänkte oss. skulle behöva göra lite fler komponenter egentligen, vi har ju inga tuffa grejer att visa liksom..]